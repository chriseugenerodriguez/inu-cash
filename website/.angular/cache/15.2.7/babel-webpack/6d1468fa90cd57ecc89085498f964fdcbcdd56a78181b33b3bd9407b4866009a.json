{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'), exports, require('@angular/core')) : typeof define === 'function' && define.amd ? define(['@angular/core', 'exports', '@angular/core'], factory) : factory(global.ng.core, global['ngx-parallax'] = {}, global.core);\n})(this, function (ɵngcc0, exports, core) {\n  'use strict';\n\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n  \r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n  \r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n  /* global Reflect, Promise */\n  function __decorate(decorators, target, key, desc) {\n    var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n  function __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n  }\n\n  // ngx-parallax\n  var Parallax = /** @class */function () {\n    function Parallax(element) {\n      var _this = this;\n      this.name = 'parallaxDirective';\n      // the following @Inputs are all part of the config object, which for \n      // brevity's sake, you can do a bunch of operations in bulk by passing \n      // in the config object; caveat for this is that angular 2 won't permit \n      // more than 9 keys being passed in an object via the template\n      this.cssKey = 'backgroundPosition';\n      this.cssProperty = 'backgroundPositionY';\n      this.axis = 'Y';\n      this.ratio = -.7;\n      this.initialValue = 0;\n      this.canMove = true;\n      this.cssUnit = 'px';\n      this.cb_context = null;\n      this.cb_args = [];\n      this.parallaxStyles = {};\n      this.isSpecialVal = false;\n      this.evaluateScroll = function () {\n        if (_this.canMove) {\n          var resultVal = void 0;\n          var calcVal = void 0;\n          if (_this.scrollElement instanceof Window) calcVal = _this.scrollElement.scrollY * _this.ratio + _this.initialValue;else calcVal = _this.scrollElement.scrollTop * _this.ratio + _this.initialValue;\n          if (_this.maxValue !== undefined && calcVal >= _this.maxValue) calcVal = _this.maxValue;else if (_this.minValue !== undefined && calcVal <= _this.minValue) calcVal = _this.minValue;\n          // added after realizing original setup wasn't compatible in Firefox\n          // debugger;\n          if (_this.cssKey === 'backgroundPosition') {\n            if (_this.axis === 'X') {\n              resultVal = 'calc(50% + ' + calcVal + _this.cssUnit + ') center';\n            } else {\n              resultVal = 'center calc(50% + ' + calcVal + _this.cssUnit + ')';\n            }\n          } else if (_this.isSpecialVal) {\n            resultVal = _this.cssValue + '(' + calcVal + _this.cssUnit + ')';\n          } else {\n            resultVal = calcVal + _this.cssUnit;\n          }\n          if (_this.cb) {\n            // console.log('this should be running')\n            _this.cb.apply(_this.cb_context, _this.cb_args);\n          }\n          _this.parallaxElement.style[_this.cssKey] = resultVal;\n        }\n      };\n      this.hostElement = element.nativeElement;\n    }\n    Parallax.prototype.ngOnInit = function () {\n      var cssValArray;\n      // console.log('%s initialized on element', this.name, this.hostElement);\n      // console.log(this);\n      for (var prop in this.config) {\n        this[prop] = this.config[prop];\n      }\n      this.cssProperty = this.cssProperty ? this.cssProperty : 'backgroundPositionY';\n      if (this.cssProperty.match(/backgroundPosition/i)) {\n        if (this.cssProperty.split('backgroundPosition')[1].toUpperCase() === 'X') {\n          this.axis = 'X';\n        }\n        this.cssProperty = 'backgroundPosition';\n      }\n      cssValArray = this.cssProperty.split(':');\n      this.cssKey = cssValArray[0];\n      this.cssValue = cssValArray[1];\n      this.isSpecialVal = this.cssValue ? true : false;\n      if (!this.cssValue) this.cssValue = this.cssKey;\n      this.ratio = +this.ratio;\n      this.initialValue = +this.initialValue;\n      this.parallaxElement = this.parallaxElement || this.hostElement;\n      if (!this.scrollElement) {\n        if (document.getElementById('parallaxScroll')) this.scrollElement = document.getElementById('parallaxScroll');else if (this.scrollerId) {\n          try {\n            this.scrollElement = document.getElementById(this.scrollerId);\n            if (!this.scrollElement) throw \"The ID passed through the parallaxConfig ('\" + this.scrollerId + \"') object was not found in the document.  Defaulting to tracking the scrolling of the window.\";\n          } catch (e) {\n            console.warn(e);\n            this.scrollElement = window;\n          }\n        } else this.scrollElement = window;\n      }\n      this.evaluateScroll();\n      this.scrollElement.addEventListener('scroll', this.evaluateScroll.bind(this));\n    };\n    __decorate([core.Input(), __metadata(\"design:type\", Object)], Parallax.prototype, \"config\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", String)], Parallax.prototype, \"cssKey\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", String)], Parallax.prototype, \"cssProperty\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", String)], Parallax.prototype, \"axis\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Number)], Parallax.prototype, \"ratio\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Number)], Parallax.prototype, \"initialValue\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Object)], Parallax.prototype, \"canMove\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", String)], Parallax.prototype, \"scrollerId\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Number)], Parallax.prototype, \"maxValue\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Number)], Parallax.prototype, \"minValue\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", String)], Parallax.prototype, \"cssUnit\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Object)], Parallax.prototype, \"cb\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Object)], Parallax.prototype, \"cb_context\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Array)], Parallax.prototype, \"cb_args\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Object)], Parallax.prototype, \"scrollElement\", void 0);\n    __decorate([core.Input(), __metadata(\"design:type\", Object)], Parallax.prototype, \"parallaxElement\", void 0);\n    Parallax = __decorate([__metadata(\"design:paramtypes\", [typeof (_a = typeof core.ElementRef !== \"undefined\" && core.ElementRef) === \"function\" && _a || Object])], Parallax);\n    Parallax.ɵfac = function Parallax_Factory(t) {\n      return new (t || Parallax)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof core.ElementRef !== \"undefined\" && core.ElementRef) === \"function\" && _a || Object));\n    };\n    Parallax.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n      type: Parallax,\n      selectors: [[\"\", \"parallax\", \"\"]],\n      inputs: {\n        cssKey: \"cssKey\",\n        cssProperty: \"cssProperty\",\n        axis: \"axis\",\n        ratio: \"ratio\",\n        initialValue: \"initialValue\",\n        canMove: \"canMove\",\n        cssUnit: \"cssUnit\",\n        cb_context: \"cb_context\",\n        cb_args: \"cb_args\",\n        parallaxElement: \"parallaxElement\",\n        scrollElement: \"scrollElement\",\n        config: \"config\",\n        scrollerId: \"scrollerId\",\n        maxValue: \"maxValue\",\n        minValue: \"minValue\",\n        cb: \"cb\"\n      }\n    });\n    (function () {\n      (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n    })();\n    return Parallax;\n    var _a;\n  }();\n  var ParallaxModule = /** @class */function () {\n    function ParallaxModule() {}\n    ParallaxModule_1 = ParallaxModule;\n    ParallaxModule.forRoot = function () {\n      return {\n        ngModule: ParallaxModule_1,\n        providers: []\n      };\n    };\n    ParallaxModule.ɵfac = function ParallaxModule_Factory(t) {\n      return new (t || ParallaxModule)();\n    };\n    ParallaxModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n      type: ParallaxModule\n    });\n    ParallaxModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n    (function () {\n      (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n    })();\n    (function () {\n      (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ParallaxModule, {\n        declarations: [Parallax],\n        exports: [Parallax]\n      });\n    })();\n    return ParallaxModule;\n    var ParallaxModule_1;\n  }();\n  exports.Parallax = Parallax;\n  exports.ParallaxModule = ParallaxModule;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJidW5kbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxpR0FBd0U7QUFDeEUsc0VBQXNEO0FBQ3RELHlCQUFVO0FBQ1YsMEJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFJTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7cUtBVXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbFsnbmd4LXBhcmFsbGF4J10gPSB7fSksZ2xvYmFsLmNvcmUpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGNvcmUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XG5cbi8vIG5neC1wYXJhbGxheFxyXG52YXIgUGFyYWxsYXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXJhbGxheChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm5hbWUgPSAncGFyYWxsYXhEaXJlY3RpdmUnO1xyXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgQElucHV0cyBhcmUgYWxsIHBhcnQgb2YgdGhlIGNvbmZpZyBvYmplY3QsIHdoaWNoIGZvciBcclxuICAgICAgICAvLyBicmV2aXR5J3Mgc2FrZSwgeW91IGNhbiBkbyBhIGJ1bmNoIG9mIG9wZXJhdGlvbnMgaW4gYnVsayBieSBwYXNzaW5nIFxyXG4gICAgICAgIC8vIGluIHRoZSBjb25maWcgb2JqZWN0OyBjYXZlYXQgZm9yIHRoaXMgaXMgdGhhdCBhbmd1bGFyIDIgd29uJ3QgcGVybWl0IFxyXG4gICAgICAgIC8vIG1vcmUgdGhhbiA5IGtleXMgYmVpbmcgcGFzc2VkIGluIGFuIG9iamVjdCB2aWEgdGhlIHRlbXBsYXRlXHJcbiAgICAgICAgdGhpcy5jc3NLZXkgPSAnYmFja2dyb3VuZFBvc2l0aW9uJztcclxuICAgICAgICB0aGlzLmNzc1Byb3BlcnR5ID0gJ2JhY2tncm91bmRQb3NpdGlvblknO1xyXG4gICAgICAgIHRoaXMuYXhpcyA9ICdZJztcclxuICAgICAgICB0aGlzLnJhdGlvID0gLS43O1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gMDtcclxuICAgICAgICB0aGlzLmNhbk1vdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY3NzVW5pdCA9ICdweCc7XHJcbiAgICAgICAgdGhpcy5jYl9jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNiX2FyZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmFsbGF4U3R5bGVzID0ge307XHJcbiAgICAgICAgdGhpcy5pc1NwZWNpYWxWYWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmV2YWx1YXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2FuTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdFZhbCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxjVmFsID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnNjcm9sbEVsZW1lbnQgaW5zdGFuY2VvZiBXaW5kb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY1ZhbCA9IF90aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsWSAqIF90aGlzLnJhdGlvICsgX3RoaXMuaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGNWYWwgPSBfdGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbFRvcCAqIF90aGlzLnJhdGlvICsgX3RoaXMuaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm1heFZhbHVlICE9PSB1bmRlZmluZWQgJiYgY2FsY1ZhbCA+PSBfdGhpcy5tYXhWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICBjYWxjVmFsID0gX3RoaXMubWF4VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5taW5WYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNhbGNWYWwgPD0gX3RoaXMubWluVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY1ZhbCA9IF90aGlzLm1pblZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkZWQgYWZ0ZXIgcmVhbGl6aW5nIG9yaWdpbmFsIHNldHVwIHdhc24ndCBjb21wYXRpYmxlIGluIEZpcmVmb3hcclxuICAgICAgICAgICAgICAgIC8vIGRlYnVnZ2VyO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNzc0tleSA9PT0gJ2JhY2tncm91bmRQb3NpdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXhpcyA9PT0gJ1gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbCA9ICdjYWxjKDUwJSArICcgKyBjYWxjVmFsICsgX3RoaXMuY3NzVW5pdCArICcpIGNlbnRlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRWYWwgPSAnY2VudGVyIGNhbGMoNTAlICsgJyArIGNhbGNWYWwgKyBfdGhpcy5jc3NVbml0ICsgJyknO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmlzU3BlY2lhbFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbCA9IF90aGlzLmNzc1ZhbHVlICsgJygnICsgY2FsY1ZhbCArIF90aGlzLmNzc1VuaXQgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRWYWwgPSBjYWxjVmFsICsgX3RoaXMuY3NzVW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jYikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0aGlzIHNob3VsZCBiZSBydW5uaW5nJylcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYi5hcHBseShfdGhpcy5jYl9jb250ZXh0LCBfdGhpcy5jYl9hcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnBhcmFsbGF4RWxlbWVudC5zdHlsZVtfdGhpcy5jc3NLZXldID0gcmVzdWx0VmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgUGFyYWxsYXgucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjc3NWYWxBcnJheTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJXMgaW5pdGlhbGl6ZWQgb24gZWxlbWVudCcsIHRoaXMubmFtZSwgdGhpcy5ob3N0RWxlbWVudCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcyk7XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLmNvbmZpZykge1xyXG4gICAgICAgICAgICB0aGlzW3Byb3BdID0gdGhpcy5jb25maWdbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3NzUHJvcGVydHkgPSB0aGlzLmNzc1Byb3BlcnR5ID8gdGhpcy5jc3NQcm9wZXJ0eSA6ICdiYWNrZ3JvdW5kUG9zaXRpb25ZJztcclxuICAgICAgICBpZiAodGhpcy5jc3NQcm9wZXJ0eS5tYXRjaCgvYmFja2dyb3VuZFBvc2l0aW9uL2kpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNzc1Byb3BlcnR5LnNwbGl0KCdiYWNrZ3JvdW5kUG9zaXRpb24nKVsxXS50b1VwcGVyQ2FzZSgpID09PSAnWCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXhpcyA9ICdYJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNzc1Byb3BlcnR5ID0gJ2JhY2tncm91bmRQb3NpdGlvbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNzc1ZhbEFycmF5ID0gdGhpcy5jc3NQcm9wZXJ0eS5zcGxpdCgnOicpO1xyXG4gICAgICAgIHRoaXMuY3NzS2V5ID0gY3NzVmFsQXJyYXlbMF07XHJcbiAgICAgICAgdGhpcy5jc3NWYWx1ZSA9IGNzc1ZhbEFycmF5WzFdO1xyXG4gICAgICAgIHRoaXMuaXNTcGVjaWFsVmFsID0gdGhpcy5jc3NWYWx1ZSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuY3NzVmFsdWUpXHJcbiAgICAgICAgICAgIHRoaXMuY3NzVmFsdWUgPSB0aGlzLmNzc0tleTtcclxuICAgICAgICB0aGlzLnJhdGlvID0gK3RoaXMucmF0aW87XHJcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSArdGhpcy5pbml0aWFsVmFsdWU7XHJcbiAgICAgICAgdGhpcy5wYXJhbGxheEVsZW1lbnQgPSB0aGlzLnBhcmFsbGF4RWxlbWVudCB8fCB0aGlzLmhvc3RFbGVtZW50O1xyXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyYWxsYXhTY3JvbGwnKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJhbGxheFNjcm9sbCcpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbGVySWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5zY3JvbGxlcklkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKFwiVGhlIElEIHBhc3NlZCB0aHJvdWdoIHRoZSBwYXJhbGxheENvbmZpZyAoJ1wiICsgdGhpcy5zY3JvbGxlcklkICsgXCInKSBvYmplY3Qgd2FzIG5vdCBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuICBEZWZhdWx0aW5nIHRvIHRyYWNraW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHdpbmRvdy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSB3aW5kb3c7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gd2luZG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2YWx1YXRlU2Nyb2xsKCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuZXZhbHVhdGVTY3JvbGwuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgY29yZS5JbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQYXJhbGxheC5wcm90b3R5cGUsIFwiY29uZmlnXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJjc3NLZXlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGNvcmUuSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUGFyYWxsYXgucHJvdG90eXBlLCBcImNzc1Byb3BlcnR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJheGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJyYXRpb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgY29yZS5JbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQYXJhbGxheC5wcm90b3R5cGUsIFwiaW5pdGlhbFZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJjYW5Nb3ZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJzY3JvbGxlcklkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJtYXhWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgY29yZS5JbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQYXJhbGxheC5wcm90b3R5cGUsIFwibWluVmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGNvcmUuSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUGFyYWxsYXgucHJvdG90eXBlLCBcImNzc1VuaXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGNvcmUuSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGFyYWxsYXgucHJvdG90eXBlLCBcImNiXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBhcmFsbGF4LnByb3RvdHlwZSwgXCJjYl9jb250ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLklucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgUGFyYWxsYXgucHJvdG90eXBlLCBcImNiX2FyZ3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGNvcmUuSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGFyYWxsYXgucHJvdG90eXBlLCBcInNjcm9sbEVsZW1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGNvcmUuSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGFyYWxsYXgucHJvdG90eXBlLCBcInBhcmFsbGF4RWxlbWVudFwiLCB2b2lkIDApO1xyXG4gICAgUGFyYWxsYXggPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW3BhcmFsbGF4XSdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgY29yZS5FbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIGNvcmUuRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiAmJiBfYSB8fCBPYmplY3RdKVxyXG4gICAgXSwgUGFyYWxsYXgpO1xyXG4gICAgcmV0dXJuIFBhcmFsbGF4O1xyXG4gICAgdmFyIF9hO1xyXG59KCkpO1xuXG52YXIgUGFyYWxsYXhNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXJhbGxheE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIFBhcmFsbGF4TW9kdWxlXzEgPSBQYXJhbGxheE1vZHVsZTtcclxuICAgIFBhcmFsbGF4TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmdNb2R1bGU6IFBhcmFsbGF4TW9kdWxlXzEsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFBhcmFsbGF4TW9kdWxlID0gUGFyYWxsYXhNb2R1bGVfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGNvcmUuTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIFBhcmFsbGF4XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIFBhcmFsbGF4XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgUGFyYWxsYXhNb2R1bGUpO1xyXG4gICAgcmV0dXJuIFBhcmFsbGF4TW9kdWxlO1xyXG4gICAgdmFyIFBhcmFsbGF4TW9kdWxlXzE7XHJcbn0oKSk7XG5cbmV4cG9ydHMuUGFyYWxsYXggPSBQYXJhbGxheDtcbmV4cG9ydHMuUGFyYWxsYXhNb2R1bGUgPSBQYXJhbGxheE1vZHVsZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdfQ==","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}